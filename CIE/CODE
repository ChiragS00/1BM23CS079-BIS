import random

graph = {
    0: [1, 2],
    1: [0, 2, 3],
    2: [0, 1, 3],
    3: [1, 2]
}
num_vertices = len(graph)
num_colors = 4 

population_size = 50
generations = 200
mutation_rate = 0.1

def random_chromosome():
    return [random.randint(0, num_colors - 1) for _ in range(num_vertices)]

def fitness(chromosome):
    conflicts = 0
    for v in range(num_vertices):
        for neighbor in graph[v]:
            if chromosome[v] == chromosome[neighbor]:
                conflicts += 1
    return 1 / (1 + conflicts)

def selection(population):
    return max(random.sample(population, 3), key=lambda c: fitness(c))

def crossover(parent1, parent2):
    point = random.randint(0, num_vertices - 1)
    child = parent1[:point] + parent2[point:]
    return child

def mutate(chromosome):
    if random.random() < mutation_rate:
        idx = random.randint(0, num_vertices - 1)
        chromosome[idx] = random.randint(0, num_colors - 1)
    return chromosome

population = [random_chromosome() for _ in range(population_size)]

best_solution = None
best_fitness = 0

for generation in range(generations):
    new_population = []
    for _ in range(population_size):
        parent1 = selection(population)
        parent2 = selection(population)
        child = crossover(parent1, parent2)
        child = mutate(child)
        new_population.append(child)
    
    population = new_population
    fittest = max(population, key=lambda c: fitness(c))
    fit = fitness(fittest)
    if fit > best_fitness:
        best_solution, best_fitness = fittest, fit

    print(f"Gen {generation}: Best Fitness = {best_fitness:.4f}")

    if best_fitness == 1.0:
        break

print("\nBest Coloring:", best_solution)
print("Conflicts:", int((1 / best_fitness) - 1))
